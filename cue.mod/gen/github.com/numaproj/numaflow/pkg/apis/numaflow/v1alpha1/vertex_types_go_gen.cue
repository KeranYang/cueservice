// Code generated by cue get go. DO NOT EDIT.

//cue:generate cue get go github.com/numaproj/numaflow/pkg/apis/numaflow/v1alpha1

package v1alpha1

import (
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	corev1 "k8s.io/api/core/v1"
)

// +kubebuilder:validation:Enum="";Pending;Running;Succeeded;Failed
#VertexPhase: string // #enumVertexPhase

#enumVertexPhase:
	#VertexPhaseUnknown |
	#VertexPhasePending |
	#VertexPhaseRunning |
	#VertexPhaseSucceeded |
	#VertexPhaseFailed

#VertexPhaseUnknown:   #VertexPhase & ""
#VertexPhasePending:   #VertexPhase & "Pending"
#VertexPhaseRunning:   #VertexPhase & "Running"
#VertexPhaseSucceeded: #VertexPhase & "Succeeded"
#VertexPhaseFailed:    #VertexPhase & "Failed"

#VertexType: string // #enumVertexType

#enumVertexType:
	#VertexTypeSource |
	#VertexTypeSink |
	#VertexTypeMapUDF |
	#VertexTypeReduceUDF

#VertexTypeSource:    #VertexType & "Source"
#VertexTypeSink:      #VertexType & "Sink"
#VertexTypeMapUDF:    #VertexType & "MapUDF"
#VertexTypeReduceUDF: #VertexType & "ReduceUDF"

// +genclient
// +kubebuilder:object:root=true
// +kubebuilder:resource:shortName=vtx
// +kubebuilder:subresource:status
// +kubebuilder:subresource:scale:specpath=.spec.replicas,statuspath=.status.replicas,selectorpath=.status.selector
// +kubebuilder:printcolumn:name="Phase",type=string,JSONPath=`.status.phase`
// +kubebuilder:printcolumn:name="Reason",type=string,JSONPath=`.status.reason`
// +kubebuilder:printcolumn:name="Message",type=string,JSONPath=`.status.message`
// +kubebuilder:printcolumn:name="Desired",type=string,JSONPath=`.spec.replicas`
// +kubebuilder:printcolumn:name="Current",type=string,JSONPath=`.status.replicas`
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
// +k8s:openapi-gen=true
#Vertex: {
	metav1.#TypeMeta
	metadata?: metav1.#ObjectMeta @go(ObjectMeta) @protobuf(1,bytes,opt)
	spec:      #VertexSpec        @go(Spec) @protobuf(2,bytes,opt)

	// +optional
	status?: #VertexStatus @go(Status) @protobuf(3,bytes,opt)
}

#VertexSpec: {
	#AbstractVertex
	pipelineName: string @go(PipelineName) @protobuf(2,bytes,opt)

	// +optional
	interStepBufferServiceName?: string @go(InterStepBufferServiceName) @protobuf(3,bytes,opt)

	// +kubebuilder:default=1
	// +optional
	replicas?: null | int32 @go(Replicas,*int32) @protobuf(4,varint,opt)

	// +optional
	fromEdges?: [...#CombinedEdge] @go(FromEdges,[]CombinedEdge) @protobuf(5,bytes,rep)

	// +optional
	toEdges?: [...#CombinedEdge] @go(ToEdges,[]CombinedEdge) @protobuf(6,bytes,rep)

	// Watermark indicates watermark progression in the vertex, it's populated from the pipeline watermark settings.
	// +kubebuilder:default={"disabled": false}
	// +optional
	watermark?: #Watermark @go(Watermark) @protobuf(7,bytes,opt)
}

#AbstractVertex: {
	name: string @go(Name) @protobuf(1,bytes,opt)

	// +optional
	source?: null | #Source @go(Source,*Source) @protobuf(2,bytes,opt)

	// +optional
	sink?: null | #Sink @go(Sink,*Sink) @protobuf(3,bytes,opt)

	// +optional
	udf?: null | #UDF @go(UDF,*UDF) @protobuf(4,bytes,opt)

	// Container template for the main numa container.
	// +optional
	containerTemplate?: null | #ContainerTemplate @go(ContainerTemplate,*ContainerTemplate) @protobuf(5,bytes,opt)

	// Container template for all the vertex pod init containers spawned by numaflow, excluding the ones specified by the user.
	// +optional
	initContainerTemplate?: null | #ContainerTemplate @go(InitContainerTemplate,*ContainerTemplate) @protobuf(6,bytes,opt)

	#AbstractPodTemplate

	// +optional
	// +patchStrategy=merge
	// +patchMergeKey=name
	volumes?: [...corev1.#Volume] @go(Volumes,[]corev1.Volume) @protobuf(8,bytes,rep)

	// Limits define the limitations such as buffer read batch size for all the vertices of a pipeline, will override pipeline level settings
	// +optional
	limits?: null | #VertexLimits @go(Limits,*VertexLimits) @protobuf(9,bytes,opt)

	// Settings for autoscaling
	// +optional
	scale?: #Scale @go(Scale) @protobuf(10,bytes,opt)

	// List of customized init containers belonging to the pod.
	// More info: https://kubernetes.io/docs/concepts/workloads/pods/init-containers/
	// +optional
	initContainers?: [...corev1.#Container] @go(InitContainers,[]corev1.Container) @protobuf(11,bytes,rep)

	// List of customized sidecar containers belonging to the pod.
	// +optional
	sidecars?: [...corev1.#Container] @go(Sidecars,[]corev1.Container) @protobuf(12,bytes,rep)

	// Number of partitions of the vertex owned buffers.
	// It applies to udf and sink vertices only.
	// +optional
	partitions?: null | int32 @go(Partitions,*int32) @protobuf(13,bytes,opt)

	// Names of the side inputs used in this vertex.
	// +optional
	sideInputs?: [...string] @go(SideInputs,[]string) @protobuf(14,bytes,rep)

	// Container template for the side inputs watcher container.
	// +optional
	sideInputsContainerTemplate?: null | #ContainerTemplate @go(SideInputsContainerTemplate,*ContainerTemplate) @protobuf(15,bytes,opt)
}

// Scale defines the parameters for autoscaling.
#Scale: {
	// Whether to disable autoscaling.
	// Set to "true" when using Kubernetes HPA or any other 3rd party autoscaling strategies.
	// +optional
	disabled?: bool @go(Disabled) @protobuf(1,bytes,opt)

	// Minimum replicas.
	// +optional
	min?: null | int32 @go(Min,*int32) @protobuf(2,varint,opt)

	// Maximum replicas.
	// +optional
	max?: null | int32 @go(Max,*int32) @protobuf(3,varint,opt)

	// Lookback seconds to calculate the average pending messages and processing rate.
	// +optional
	lookbackSeconds?: null | uint32 @go(LookbackSeconds,*uint32) @protobuf(4,varint,opt)

	// Deprecated: Use scaleUpCooldownSeconds and scaleDownCooldownSeconds instead.
	// Cooldown seconds after a scaling operation before another one.
	// +optional
	cooldownSeconds?: null | uint32 @go(DeprecatedCooldownSeconds,*uint32) @protobuf(5,varint,opt)

	// After scaling down the source vertex to 0, sleep how many seconds before scaling the source vertex back up to peek.
	// +optional
	zeroReplicaSleepSeconds?: null | uint32 @go(ZeroReplicaSleepSeconds,*uint32) @protobuf(6,varint,opt)

	// TargetProcessingSeconds is used to tune the aggressiveness of autoscaling for source vertices, it measures how fast
	// you want the vertex to process all the pending messages. Typically increasing the value, which leads to lower processing
	// rate, thus less replicas. It's only effective for source vertices.
	// +optional
	targetProcessingSeconds?: null | uint32 @go(TargetProcessingSeconds,*uint32) @protobuf(7,varint,opt)

	// TargetBufferAvailability is used to define the target percentage of the buffer availability.
	// A valid and meaningful value should be less than the BufferUsageLimit defined in the Edge spec (or Pipeline spec), for example, 50.
	// It only applies to UDF and Sink vertices because only they have buffers to read.
	// +optional
	targetBufferAvailability?: null | uint32 @go(TargetBufferAvailability,*uint32) @protobuf(8,varint,opt)

	// ReplicasPerScale defines maximum replicas can be scaled up or down at once.
	// The is use to prevent too aggressive scaling operations
	// +optional
	replicasPerScale?: null | uint32 @go(ReplicasPerScale,*uint32) @protobuf(9,varint,opt)

	// ScaleUpCooldownSeconds defines the cooldown seconds after a scaling operation, before a follow-up scaling up.
	// It defaults to the CooldownSeconds if not set.
	// +optional
	scaleUpCooldownSeconds?: null | uint32 @go(ScaleUpCooldownSeconds,*uint32) @protobuf(10,varint,opt)

	// ScaleDownCooldownSeconds defines the cooldown seconds after a scaling operation, before a follow-up scaling down.
	// It defaults to the CooldownSeconds if not set.
	// +optional
	scaleDownCooldownSeconds?: null | uint32 @go(ScaleDownCooldownSeconds,*uint32) @protobuf(11,varint,opt)
}

#VertexLimits: {
	// Read batch size from the source or buffer.
	// It overrides the settings from pipeline limits.
	// +optional
	readBatchSize?: null | uint64 @go(ReadBatchSize,*uint64) @protobuf(1,varint,opt)

	// Read timeout duration from the source or buffer
	// It overrides the settings from pipeline limits.
	// +optional
	readTimeout?: null | metav1.#Duration @go(ReadTimeout,*metav1.Duration) @protobuf(2,bytes,opt)

	// BufferMaxLength is used to define the max length of a buffer.
	// It overrides the settings from pipeline limits.
	// +optional
	bufferMaxLength?: null | uint64 @go(BufferMaxLength,*uint64) @protobuf(3,varint,opt)

	// BufferUsageLimit is used to define the percentage of the buffer usage limit, a valid value should be less than 100, for example, 85.
	// It overrides the settings from pipeline limits.
	// +optional
	bufferUsageLimit?: null | uint32 @go(BufferUsageLimit,*uint32) @protobuf(4,varint,opt)
}

#VertexStatus: {
	phase:         #VertexPhase @go(Phase) @protobuf(1,bytes,opt,casttype=VertexPhase)
	reason?:       string       @go(Reason) @protobuf(6,bytes,opt)
	message?:      string       @go(Message) @protobuf(2,bytes,opt)
	replicas:      uint32       @go(Replicas) @protobuf(3,varint,opt)
	selector?:     string       @go(Selector) @protobuf(5,bytes,opt)
	lastScaledAt?: metav1.#Time @go(LastScaledAt) @protobuf(4,bytes,opt)
}

// +kubebuilder:object:root=true
// +k8s:deepcopy-gen:interfaces=k8s.io/apimachinery/pkg/runtime.Object
#VertexList: {
	metav1.#TypeMeta
	metadata?: metav1.#ListMeta @go(ListMeta) @protobuf(1,bytes,opt)
	items: [...#Vertex] @go(Items,[]Vertex) @protobuf(2,bytes,rep)
}

#VertexTemplate: {
	#AbstractPodTemplate

	// Template for the vertex numa container
	// +optional
	containerTemplate?: null | #ContainerTemplate @go(ContainerTemplate,*ContainerTemplate) @protobuf(2,bytes,opt)

	// Template for the vertex init container
	// +optional
	initContainerTemplate?: null | #ContainerTemplate @go(InitContainerTemplate,*ContainerTemplate) @protobuf(3,bytes,opt)
}
